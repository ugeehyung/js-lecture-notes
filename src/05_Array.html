<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열</title>
</head>
<body>
    
<h3># Javascript Array</h3>

<script>
    fruits = ['apple', 'banana', 'orange'];

    console.log(fruits[0]);
    console.log(fruits[1]);
    console.log(fruits[2]);

    document.write(fruits + '<br>');
    document.write(fruits[0] + '<br>');
    document.write(fruits[1] + '<br>');
    document.write(fruits[2] + '<br>');

    console.log('배열의 타입:', typeof fruits);

    snacks = new Array('칙촉', '쿠앤크', '초코파이');
    console.log(fruits);
    console.log(snacks);

    document.write('<ul>');
    for (i = 0; i < snacks.length; ++i) {
        document.write('<li><a href="#">' + snacks[i] + '</a></li>');
    }
    document.write('</ul>')

    console.log(fruits.__proto__.length);
    console.log(snacks.__proto__.length);

    a = 10;
    b = 'hello';
    c = function() {
        return 10;
    };
    d = {
        name: 'John',
        age: 12,
    };

    // typeof만으로는 object가 배열인지 아닌지를 알 수 없다
    console.log(typeof d === typeof fruits);
    
    // Array.isArray()
    console.log('fruits is array:', Array.isArray(fruits));
    console.log('d is array:', Array.isArray(d));

    console.log('fruits is instanceof array:', fruits instanceof Array);
    console.log('d is instanceof array:', d instanceof Array);   
    
    // array.join()
    result = fruits.join('/');
    console.log(result);

    // array.pop() : 배열의 맨 뒤 내용을 하나씩 꺼내며(삭제하며) 사용한다
    console.log(fruits.pop());
    console.log(fruits.pop());
    console.log(fruits.pop());
    console.log(fruits.pop());

    // array.push() : 배열의 맨 뒤에 내용을 하나씩 추가한다
    fruits.push('apple');
    fruits.push('kiwi');
    fruits.push('strawberry');
    fruits.push('mango');
    console.log(fruits);

    // array.fill() : 존재하는 모든 값을 하나의 값으로 초기화 한다
    fruits.fill('');
    console.log(fruits);

    
    Array.prototype.toSource = function() {
        return '[\'a\', \'b\', \'c\']';
    }
    console.log(fruits.toSource());    

    // array.copyWithin(복사를 시작할 위치, 복사 시작 인덱스, 복사 끝 인덱스)
    const array1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'];
    
    console.log(array1.copyWithin(3, 0, 3));    
    console.log(array1);

    // array.reduce()
    const array2 = [1, 2, 3, 4];

    // arrow function (a, b) => a + b
    const reducer = (accumulator, currentValue) => accumulator * currentValue;
    
    const reducer2 = function (acc, curr) {
        return acc * curr;
    };

    // 1 + 2 + 3 + 4
    console.log(array2.reduce(reducer2));
    // expected output: 10

    // 5 + 1 + 2 + 3 + 4
    console.log(array2.reduce(reducer2, 5));
    // expected output: 15    

    // reduce()를 이용해 배열 내에서 최대값(또는 최소값) 구하기 
    const reducer3 = (a, b) => a > b ? a : b;
    console.log('배열 내 최대값: ', array2.reduce(reducer3));
    console.log('배열 내 최소값: ', array2.reduce((a, b) => a < b ? a : b));


    // callback이란?    
    //  - callback 자리에 함수를 정의만 해놓으면 필요할때마다 무언가에게 호출되는 방식으로 사용되는 함수
    //  - ex: addActionListener(callback) 

    // for ... in

    // for ... of
</script>

</body>
</html>
